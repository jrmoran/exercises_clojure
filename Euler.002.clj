;; ##002
;; Each new term in the Fibonacci sequence is generated by adding
;; the previous two terms.
;;
;; By starting with 1 and 2, the first 10 terms will be:
;;
;; `1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...`
;;
;; By considering the terms in the Fibonacci sequence whose values
;; do not exceed four million, find the sum of the even-valued terms.


;; ##Solution
;; To obtain the Fibonacci sequence given in the problem description I
;; can use this recursive function which takes an empty collection, the
;; first and second items in the sequence, and also the limit
(defn fib-seq [result previous current limit]
  (if (> previous limit)
    result
    (let [next-n (+ previous current)]
      (recur (conj result previous) current next-n limit))))

(fib-seq [] 1 2 100)                  ; => [1 2 3 5 8 13 21 34 55 89]

;; Then, I need to filter the results to find its even items
(filter even? (fib-seq [] 1 2 100))   ; (2 8 34)

;; And finally perform the sum
(reduce
  + (filter
      even? (fib-seq [] 1 2 100)))    ; 44


;; ##Putting it together
;; The `fib-seq` function is now an auto-executable function inside
;; `sum-fib-evens-until`
(defn sum-fib-evens-until [limit]
  " Returns the sum of all even numbers in a Fibonacci sequence until 
    the specified limit."
  (reduce
    + (filter
        even? ((fn [result previous current ]
                 (if (> previous limit)
                   result
                   (recur (conj result previous)
                          current
                          (+ previous current)))) [] 1 2 ))))

;; Sum of evens until 100
(sum-fib-evens-until 100)               ; 44

;; ##Answer
(def ans (sum-fib-evens-until 4000000)) ; 4613732

(println ans)

;; ##Solution B
;; The ratio between a number and the next in a Fibonacci sequence is
;; approximate to the golden ratio `1.618033989`.
;;
;; Every third element in the Fibonacci sequence is even hence the ratio
;; for even numbers is the golden ratio to the third power: `4.23606797946414`

(use 'clojure.contrib.math)
(defn solution [limit]
  (reduce
   + ((fn [ result number ]
         (if (> number limit)
           result
           (recur (conj result number)
                  (round (* number 4.23606797946414))))) [] 2)))

(solution 4000000)                        ; 4613732

; Measurements
(println "\nsum-fib-evens-until")
(dotimes [_ 5] (time (sum-fib-evens-until 4000000)))   ; faster
(println "\nsolution")
(dotimes [_ 5] (time (solution 4000000)))
